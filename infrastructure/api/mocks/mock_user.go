// Code generated by MockGen. DO NOT EDIT.
// Source: ./user.go

// Package mocks is a generated GoMock package.
package mocks

import (
	gomock "github.com/golang/mock/gomock"
	model "lahaus/domain/model"
	users "lahaus/domain/usecases/users"
	reflect "reflect"
)

// MockSignInUserExecutor is a mock of SignInUserExecutor interface
type MockSignInUserExecutor struct {
	ctrl     *gomock.Controller
	recorder *MockSignInUserExecutorMockRecorder
}

// MockSignInUserExecutorMockRecorder is the mock recorder for MockSignInUserExecutor
type MockSignInUserExecutorMockRecorder struct {
	mock *MockSignInUserExecutor
}

// NewMockSignInUserExecutor creates a new mock instance
func NewMockSignInUserExecutor(ctrl *gomock.Controller) *MockSignInUserExecutor {
	mock := &MockSignInUserExecutor{ctrl: ctrl}
	mock.recorder = &MockSignInUserExecutorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockSignInUserExecutor) EXPECT() *MockSignInUserExecutorMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockSignInUserExecutor) Execute(user *model.User) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", user)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute
func (mr *MockSignInUserExecutorMockRecorder) Execute(user interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockSignInUserExecutor)(nil).Execute), user)
}

// MockSignUpUserExecutor is a mock of SignUpUserExecutor interface
type MockSignUpUserExecutor struct {
	ctrl     *gomock.Controller
	recorder *MockSignUpUserExecutorMockRecorder
}

// MockSignUpUserExecutorMockRecorder is the mock recorder for MockSignUpUserExecutor
type MockSignUpUserExecutorMockRecorder struct {
	mock *MockSignUpUserExecutor
}

// NewMockSignUpUserExecutor creates a new mock instance
func NewMockSignUpUserExecutor(ctrl *gomock.Controller) *MockSignUpUserExecutor {
	mock := &MockSignUpUserExecutor{ctrl: ctrl}
	mock.recorder = &MockSignUpUserExecutorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockSignUpUserExecutor) EXPECT() *MockSignUpUserExecutorMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockSignUpUserExecutor) Execute(email, password string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", email, password)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute
func (mr *MockSignUpUserExecutorMockRecorder) Execute(email, password interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockSignUpUserExecutor)(nil).Execute), email, password)
}

// MockAddFavouriteExecutor is a mock of AddFavouriteExecutor interface
type MockAddFavouriteExecutor struct {
	ctrl     *gomock.Controller
	recorder *MockAddFavouriteExecutorMockRecorder
}

// MockAddFavouriteExecutorMockRecorder is the mock recorder for MockAddFavouriteExecutor
type MockAddFavouriteExecutorMockRecorder struct {
	mock *MockAddFavouriteExecutor
}

// NewMockAddFavouriteExecutor creates a new mock instance
func NewMockAddFavouriteExecutor(ctrl *gomock.Controller) *MockAddFavouriteExecutor {
	mock := &MockAddFavouriteExecutor{ctrl: ctrl}
	mock.recorder = &MockAddFavouriteExecutorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAddFavouriteExecutor) EXPECT() *MockAddFavouriteExecutorMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockAddFavouriteExecutor) Execute(userID, property int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", userID, property)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute
func (mr *MockAddFavouriteExecutorMockRecorder) Execute(userID, property interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockAddFavouriteExecutor)(nil).Execute), userID, property)
}

// MockListFavouritesExecutor is a mock of ListFavouritesExecutor interface
type MockListFavouritesExecutor struct {
	ctrl     *gomock.Controller
	recorder *MockListFavouritesExecutorMockRecorder
}

// MockListFavouritesExecutorMockRecorder is the mock recorder for MockListFavouritesExecutor
type MockListFavouritesExecutorMockRecorder struct {
	mock *MockListFavouritesExecutor
}

// NewMockListFavouritesExecutor creates a new mock instance
func NewMockListFavouritesExecutor(ctrl *gomock.Controller) *MockListFavouritesExecutor {
	mock := &MockListFavouritesExecutor{ctrl: ctrl}
	mock.recorder = &MockListFavouritesExecutorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockListFavouritesExecutor) EXPECT() *MockListFavouritesExecutorMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockListFavouritesExecutor) Execute(search users.FavouritesSearchParams) (*model.PropertiesPaging, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", search)
	ret0, _ := ret[0].(*model.PropertiesPaging)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute
func (mr *MockListFavouritesExecutorMockRecorder) Execute(search interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockListFavouritesExecutor)(nil).Execute), search)
}
